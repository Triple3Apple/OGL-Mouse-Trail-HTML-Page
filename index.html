<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OGL Mouse Trail</title>
    <style>
        :root {
            overflow: hidden;
            height: 100%;
        }

        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script type="module">
        import {
            Renderer,
            Camera,
            Orbit,
            Transform,
            Geometry,
            Vec3,
            Color,
            Polyline
        } from "../OGL/index.mjs";
        {
            const vertex = `
            attribute vec3 position;
            attribute vec3 next;
            attribute vec3 prev;
            attribute vec2 uv;
            attribute float side;

            uniform vec2 uResolution;
            uniform float uDPR;
            uniform float uThickness;

            vec4 getPosition() {
                vec2 aspect = vec2(uResolution.x / uResolution.y, 1);
                vec2 nextScreen = next.xy * aspect;
                vec2 prevScreen = prev.xy * aspect;

                // determine the direction from the previous to the next point
                vec2 tangent = normalize(nextScreen - prevScreen);

                // rotate it 90 degrees to find the normal
                vec2 normal = vec2(-tangent.y, tangent.x);
                normal /= aspect;

                // line's width, without this, the line width = whole screen
                //normal *= 0.1;   // simple line
                //normal *= uv.y * 0.2;   // triangle shape
                //normal *= pow(uv.y, 2.0) * 0.2; // curved triangle
                //normal *= cos(uv.y * 12.56) * 0.1 + 0.2;    // curvy line
                //normal *= (1.0 - pow(abs(uv.y - 0.5) * 2.0, 2.0)) * 0.2;    // thin on sides, thick in the middle
                
                //normal *= 1.0 - pow(abs(uv.y - 0.5) * 2.0, 2.0);
                normal *= 1.0 - pow(abs(uv.y - 0.5) * 2.0, 2.0);

                float pixelWidth = 1.0 / (uResolution.y / uDPR);
                normal *= pixelWidth * uThickness;

                // When the points are on top of each other, 
                // shrink the line to avoid artifacts.
                float dist = length(nextScreen - prevScreen);
                normal *= smoothstep(0.0, 0.02, dist);

                vec4 current = vec4(position, 1);

                // push our vertices apart along the normal
                current.xy -= normal * side;
                return current;
            }

            void main() {
                gl_Position = getPosition();
            }
        `;

            // Create the WebGL context, and add the canvas to the DOM
            const renderer = new Renderer({ dpr: 2 });
            const gl = renderer.gl;
            document.body.appendChild(gl.canvas);
            gl.clearColor(0.3, 0.05, 0.1, 1);

            //const controls = new Orbit(camera);
            const scene = new Transform();
            //let polyline;
            const lines = [];

            function resize() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                //if (polyline) polyline.resize();
                // We call resize on the polylines to update their resolution uniforms
                lines.forEach(line => line.polyline.resize());
            }
            window.addEventListener("resize", resize, false);

            // Create an array of Vec3s (eg [[0, 0, 0], ...])
            // sine wave
            /*
            const count = 100;
            const points = [];
            for (let i = 0; i < count; i++) {
                const x = (i / (count - 1) - 0.5) * 3;
                const y = Math.sin(i / 10.5) * 0.5;
                const z = 0;

                points.push(new Vec3(x, y, z));
            }
            */

            // square
            /*
            const points = [];
            points.push(new Vec3(0, -1, 0));
            points.push(new Vec3(-1, -1, 0));
            points.push(new Vec3(-1, 1, 0));
            points.push(new Vec3(1, 1, 0));
            points.push(new Vec3(1, -1, 0));
            points.push(new Vec3(0, -1, 0));
            */

            // circle
            /*
            const count = 100;
            const points = [];
            for (let i = 0; i < count; i++) {
                const angle = i / (count - 2) * Math.PI * 2;
                const x = Math.cos(angle);
                const y = Math.sin(angle);
                const z = 0;

                points.push(new Vec3(x, y, z));
            };
            */

            function random(a, b) {
                const alpha = Math.random();
                return a * (1.0 - alpha) + b * alpha;
            }

            // We're going to make a number of different coloured lines for fun.
            ["#e09f7d", "#ef5d60", "#ec4067", "#a01a7d", "#311847"].forEach(
                (color, i) => {

                    const line = {
                        spring: random(0.02, 0.1),
                        friction: random(0.7, 0.95),
                        mouseVelocity: new Vec3(),
                        mouseOffset: new Vec3(random(-1, 1) * 0.02)
                    };

                    const count = 20;
                    const points = (line.points = []);
                    for (let i = 0; i < count; i++) points.push(new Vec3());

                    line.polyline = new Polyline(gl, {
                        points,
                        vertex,
                        uniforms: {
                            uColor: { value: new Color(color) },
                            uThickness: { value: random(20, 50) }
                        }
                    });

                    line.polyline.mesh.setParent(scene);

                    lines.push(line);
                });

            // Call initial resize after creating the polyline to update 
            // its resolution uniforms
            resize();

            // Add handlers to get mouse position
            const mouse = new Vec3();
            if ("ontouchstart" in window) {
                window.addEventListener("touchstart", updateMouse, false);
                window.addEventListener("touchmove", updateMouse, false);
            } else {
                window.addEventListener("mousemove", updateMouse, false);
            }

            function updateMouse(e) {
                if (e.changedTouches && e.changedTouches.length) {
                    e.x = e.changedTouches[0].pageX;
                    e.y = e.changedTouches[0].pageY;
                }
                if (e.x === undefined) {
                    e.x = e.pageX;
                    e.y = e.pageY;
                }

                // Get mouse value in -1 to 1 range, with y flipped
                mouse.set(
                    (e.x / gl.renderer.width) * 2 - 1,
                    (e.y / gl.renderer.height) * -2 + 1,
                    0
                );
            }

            const tmp = new Vec3();
            //const spring = 0.06;
            //const friction = 0.85;
            //const mouseVelocity = new Vec3();

            // render scene in an update loop
            requestAnimationFrame(update);
            function update(t) {
                requestAnimationFrame(update);

                // Update polyline input points
                lines.forEach(line => {
                    // Update polyline input points
                    for (let i = line.points.length - 1; i >= 0; i--) {
                        if (!i) {
                            // For the first point, spring ease it to the mouse position
                            tmp
                                .copy(mouse)
                                .add(line.mouseOffset)
                                .sub(line.points[i])
                                .multiply(line.spring);
                            line.mouseVelocity.add(tmp).multiply(line.friction);
                            line.points[i].add(line.mouseVelocity);
                        } else {
                            // The rest of the points ease to the point in front of them, making a line
                            line.points[i].lerp(line.points[i - 1], 0.9);
                        }
                    }
                    line.polyline.updateGeometry();
                });

                renderer.render({ scene });
            }
        }
    </script>
</body>

</html>